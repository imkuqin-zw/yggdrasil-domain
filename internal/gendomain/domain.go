package gendomain

import (
	"errors"
	"fmt"
	"strings"

	"github.com/imkuqin-zw/yggdrasil-domain/proto/yggdrasil/domain"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	fmtPackage   = protogen.GoImportPath("fmt")
	protoPackage = protogen.GoImportPath("google.golang.org/protobuf/proto")
)

// GenerateFile generates a _domain.pb.go file containing yggdrasil domain definitions.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) error {
	pass := false
	for _, message := range file.Messages {
		event, ok := proto.GetExtension(message.Desc.Options(), domain.E_Event).(*domain.Event)
		if event != nil && ok {
			pass = true
			break
		}
	}
	if !pass {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_domain.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-yggdrasil-domain. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	return generateFileContent(file, g)
}

// generateFileContent generates the yggdrasil domain definitions, excluding the package statement.
func generateFileContent(file *protogen.File, g *protogen.GeneratedFile) error {
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the yggdrasil package it is being compiled against.")
	g.P("var _ = ", protoPackage.Ident("Message"), "(nil)")
	g.P("var _ = ", fmtPackage.Ident("GoStringer"), "(nil)")
	g.P()

	desc := &domainDesc{
		FmtPkg:   g.QualifiedGoIdent(fmtPackage.Ident("")),
		ProtoPkg: g.QualifiedGoIdent(protoPackage.Ident("")),
		Events:   make([]*EventDesc, 0),
	}
	if err := fillEvents(file, desc); err != nil {
		return err
	}
	g.P(desc.execute())
	return nil
}

func fillEvents(file *protogen.File, desc *domainDesc) error {
	for _, message := range file.Messages {
		event, err := getEvent(message)
		if err != nil {
			return err
		}
		if event == nil {
			continue
		}
		desc.Events = append(desc.Events, event)
	}
	return nil
}

func getEvent(message *protogen.Message) (*EventDesc, error) {
	event, ok := proto.GetExtension(message.Desc.Options(), domain.E_Event).(*domain.Event)
	if !ok {
		return nil, nil
	}
	if len(event.IDFields) == 0 {
		return nil, errors.New("IDFields can not be empty")
	}
	desc := &EventDesc{
		MessageName: message.GoIdent.GoName,
		Topic:       event.Topic,
	}
	format := make([]string, 0, len(event.IDFields))
	fields := make([]string, 0, len(event.IDFields))
	for _, field := range event.IDFields {
		found := false
		for _, item := range message.Fields {
			if string(item.Desc.Name()) == field {
				fieldGoName := "e." + item.GoName
				switch item.Desc.Kind() {
				case protoreflect.EnumKind,
					protoreflect.Int32Kind, protoreflect.Sint32Kind,
					protoreflect.Uint32Kind, protoreflect.Int64Kind,
					protoreflect.Sint64Kind, protoreflect.Uint64Kind,
					protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind:
					format = append(format, "%d")
				case protoreflect.StringKind:
					format = append(format, "%s")
				default:
					return nil, fmt.Errorf("invalid field kind to generate event ID: field(%s), kind(%s)", item.Desc.Name(), item.Desc.Kind())
				}
				fields = append(fields, fieldGoName)
				found = true
				break
			}
		}
		if !found {
			return nil, fmt.Errorf("field(%s) can not be found in message(%s)", field, message.Desc.Name())
		}
	}
	desc.ID = EventIDDesc{
		Format: strings.Join(format, ":"),
		Args:   strings.Join(fields, ","),
	}
	return desc, nil
}
